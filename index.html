<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multiplayer 3D Driving</title>
  <style>
    body { margin:0; overflow:hidden; background:#121212; font-family:sans-serif; color:#fff; user-select:none }
    #lobby { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.8); padding:20px; border-radius:8px; display:flex; flex-direction:column; gap:8px;
    }
    #gameUI { display:none; }
    .controlBtn { padding:10px 14px; border:none; border-radius:8px;
      background:#0078d7; color:#fff; font-size:16px; cursor:pointer;
    }
  </style>
</head>
<body>
  <div id="lobby">
    <input id="nickname" placeholder="닉네임"/>
    <select id="carType">
      <option value="sedan">세단</option>
      <option value="suv">SUV</option>
    </select>
    <input type="color" id="carColor" value="#ff0000"/>
    <button id="startBtn" class="controlBtn">게임 시작</button>
  </div>

  <div id="gameUI">
    <div id="hud" style="position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.5);padding:8px;">속도: 0 km/h</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
  const socket = io();

  let scene, camera, renderer, world;
  let myCar, players = {};
  let chassisBody, vehicle, clock;
  const input = { left: false, right: false, accel: false, brake: false };

  const lobby = document.getElementById('lobby');
  const gameUI = document.getElementById('gameUI');
  const hud = document.getElementById('hud');

  document.getElementById('startBtn').onclick = () => {
    const nickname = document.getElementById('nickname').value;
    const carType = document.getElementById('carType').value;
    const carColor = document.getElementById('carColor').value;
    if (!nickname) return alert('닉네임을 입력하세요.');
    lobby.style.display = 'none';
    gameUI.style.display = 'block';
    initGame(nickname, carType, carColor);
    socket.emit('join', { nickname, carType, carColor });
  };

  socket.on('players', data => {
    for (const id in players) {
      if (!data[id]) {
        scene.remove(players[id].mesh);
        delete players[id];
      }
    }
    for (const id in data) {
      if (id === socket.id) continue;
      if (!players[id]) {
        const c = data[id];
        const mesh = makeCarModel(c.carType, c.carColor);
        scene.add(mesh);
        players[id] = { mesh };
      }
      const { position, quaternion } = data[id];
      players[id].mesh.position.set(...position);
      players[id].mesh.quaternion.set(...quaternion);
    }
  });

  function initGame(name, type, color) {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 5000);
    camera.position.set(0,5, -15);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=> {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
    const ground = new CANNON.Body({ mass:0 });
    ground.addShape(new CANNON.Plane());
    ground.quaternion.setFromEuler(-Math.PI/2,0,0);
    world.addBody(ground);

    chassisBody = new CANNON.Body({ mass:110 });
    chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.5,0.5,3)));
    world.addBody(chassisBody);

    vehicle = new CANNON.RaycastVehicle({
      chassisBody, indexRightAxis:0, indexUpAxis:1, indexForwardAxis:2
    });
    [[-1.2,0.2,2.4,true],[1.2,0.2,2.4,true],[-1.2,0.2,-2.4,false],[1.2,0.2,-2.4,false]].forEach(([x,y,z,front]) => {
      vehicle.addWheel({
        chassisConnectionPointLocal: new CANNON.Vec3(x,y,z),
        isFrontWheel: front,
        radius:0.5, directionLocal:new CANNON.Vec3(0,-1,0),
        axleLocal:new CANNON.Vec3(1,0,0),
        suspensionStiffness:30, suspensionRestLength:0.3,
        frictionSlip:5, dampingRelaxation:2, dampingCompression:2,
      });
    });
    vehicle.addToWorld(world);

    const wheelMeshes = [];
    vehicle.wheelInfos.forEach(w => {
      const m = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.4,16), new THREE.MeshStandardMaterial({color:0x222222}));
      m.rotation.z = Math.PI/2;
      scene.add(m); wheelMeshes.push(m);
    });

    myCar = makeCarModel(type, color);
    scene.add(myCar);

    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    scene.add(new THREE.DirectionalLight(0xffffff,0.8));

    clock = new THREE.Clock();

    window.addEventListener('keydown', e=> handleInput(e.key,true));
    window.addEventListener('keyup', e=> handleInput(e.key,false));

    animate();

    setInterval(() => {
      const p = chassisBody.position.toArray();
      const q = chassisBody.quaternion.toArray();
      socket.emit('update', { position:p, quaternion:q });
    }, 50);
  }

  function handleInput(k, down) {
    const map = { ArrowLeft:'left', a:'left', ArrowRight:'right', d:'right',
        ArrowUp:'accel', w:'accel', ArrowDown:'brake', s:'brake' };
    if (map[k]) input[map[k]] = down;
  }

  function makeCarModel(type, color) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color });
    const body = new THREE.Mesh(new THREE.BoxGeometry(3,1.2,6), mat);
    body.position.y = 0.6;
    group.add(body);
    return group;
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    world.step(1/60, dt, 3);

    const steer = input.left ? 0.5 : input.right ? -0.5 : 0;
    vehicle.setSteeringValue(steer, 0);
    vehicle.setSteeringValue(steer, 1);
    if (input.accel) vehicle.applyEngineForce(1500,2), vehicle.applyEngineForce(1500,3);
    if (input.brake) vehicle.setBrake(20,2), vehicle.setBrake(20,3);
    chassisBody.position.y = Math.max(chassisBody.position.y, 0.3);

    const winfos = vehicle.wheelInfos;
    for (let i=0; i<winfos.length; i++) {
      vehicle.updateWheelTransform(i);
      const t = winfos[i].worldTransform;
      scene.getObjectById(i).position.copy(t.position);
      scene.getObjectById(i).quaternion.copy(t.quaternion);
    }

    myCar.position.copy(chassisBody.position);
    myCar.quaternion.copy(chassisBody.quaternion);

    const speed = chassisBody.velocity.length() * 3.6;
    hud.innerText = `속도: ${speed.toFixed(1)} km/h`;

    camera.position.lerp(new THREE.Vector3(
      chassisBody.position.x, chassisBody.position.y+5, chassisBody.position.z-15), 0.1);
    camera.lookAt(myCar.position);

    renderer.render(scene, camera);
  }
  </script>
</body>
</html>
