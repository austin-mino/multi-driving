<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving - Multiplayer</title>
  <style>
    /* 기존 스타일 + 추가 UI 스타일 */
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
    #gearControls button.controlBtn {
      padding: 8px 12px;
      font-size: 14px;
    }
    #btnReset.controlBtn {
      padding: 8px 12px;
      font-size: 14px;
    }
    #btnToggleCam {
      position: fixed;
      top: 10px;
      right: 120px;
      padding: 10px 14px;
      font-size: 16px;
      border-radius: 12px;
      background: #0078d7;
      color: white;
      border: none;
      cursor: pointer;
      z-index: 100;
      user-select: none;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    #btnToggleCam:active {
      background: #005a9e;
    }

    /* 멀티플레이어 접속 UI */
    #loginOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    #loginOverlay label {
      margin: 8px 0 4px;
      font-size: 18px;
    }
    #loginOverlay input, #loginOverlay select {
      padding: 8px 12px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      width: 220px;
      max-width: 80vw;
    }
    #loginOverlay button {
      margin-top: 20px;
      padding: 14px 30px;
      font-size: 18px;
      font-weight: 700;
      border-radius: 12px;
      border: none;
      background: #009688;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #loginOverlay button:hover {
      background: #00796b;
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>

  <!-- 멀티플레이 접속 UI -->
  <div id="loginOverlay">
    <h2>멀티플레이 접속</h2>
    <label for="inputNickname">닉네임</label>
    <input type="text" id="inputNickname" placeholder="닉네임을 입력하세요" maxlength="12" />
    <label for="selectCarType">차량 종류</label>
    <select id="selectCarType">
      <option value="GrandeurIG">그랜저 IG</option>
      <option value="BoxCar">박스형 차량</option>
      <!-- 필요시 다른 차량 추가 가능 -->
    </select>
    <label for="inputColor">차량 색상</label>
    <input type="color" id="inputColor" value="#ffffff" />
    <button id="btnStart">게임 시작</button>
  </div>

  <!-- 기존 게임 UI -->
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀</button>
    <button id="btnRight" class="controlBtn">▶</button>
  </div>

  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">accel</button>
    <button id="btnBrake" class="controlBtn">brake</button>
    <div id="reset">
      <button id="btnReset" class="controlBtn">리셋</button>
    </div>
  </div>

  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <button id="btnToggleCam" class="controlBtn">C: ON</button>

  <!-- Three.js, Cannon-es, Socket.IO CDN -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 가로모드 체크
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // 기본 변수
    let socket;
    let myPlayerId = null;
    const otherPlayers = new Map(); // id -> { chassisBody, carModel, nameTag }

    // 내 플레이어 정보
    let playerInfo = null;

    // 3D 씬, 카메라, 렌더러 초기화
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(500, 5, 15);
    camera.lookAt(500, 0.5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 카메라 자유 시점 관련 변수 및 함수 (기존 코드 유지)
    let camAzimuth = Math.PI;
    let camElevation = Math.PI / 6;
    const camDistance = 15;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let camAzimuthStart = camAzimuth;
    let camElevationStart = camElevation;
    let cameraFollow = true;

    function onPointerDown(event) {
      if (!cameraFollow) {
        isDragging = true;
        dragStart.x = event.clientX;
        dragStart.y = event.clientY;
        camAzimuthStart = camAzimuth;
        camElevationStart = camElevation;
      }
    }
    function onPointerMove(event) {
      if (isDragging && !cameraFollow) {
        const deltaX = event.clientX - dragStart.x;
        const deltaY = event.clientY - dragStart.y;
        const rotationSpeed = 0.05;
        camAzimuth = camAzimuthStart - deltaX * rotationSpeed;
        camElevation = camElevationStart - deltaY * rotationSpeed;
        camElevation = Math.min(Math.max(camElevation, 0.1), Math.PI - 0.1);
      }
    }
    function onPointerUp(event) {
      isDragging = false;
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('pointerleave', onPointerUp);
    renderer.domElement.addEventListener('touchcancel', onPointerUp);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Cannon.js 물리 월드 설정
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    // 지면 생성
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // 트랙 타원 파라미터 및 바리어 생성 (기존 코드 유지)
    const trackA = 500;
    const trackB = 60;
    const trackWidth = 60;
    const numSegments = 400;

    const barrierHeight = 1;
    const barrierThickness = 1;
    const barrierLength = 25;
    const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const barrierMeshes = [];

    for (let i = 0; i < numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;
      const cx = Math.cos(angle);
      const sz = Math.sin(angle);

      const innerX = (trackA - trackWidth / 2) * cx;
      const innerZ = (trackB - trackWidth / 2) * sz;
      const outerX = (trackA + trackWidth / 2) * cx;
      const outerZ = (trackB + trackWidth / 2) * sz;

      // 장애물 (바리어) 생성
      if (i % 10 === 0) {
        const posX = outerX;
        const posZ = outerZ;
        const barrierGeo = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
        const barrierMesh = new THREE.Mesh(barrierGeo, barrierMat);
        barrierMesh.position.set(posX, barrierHeight / 2, posZ);
        barrierMesh.rotation.y = -angle;
        scene.add(barrierMesh);
        barrierMeshes.push(barrierMesh);

        // Cannon 바리어 물리 생성
        const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
        const barrierBody = new CANNON.Body({ mass: 0 });
        barrierBody.addShape(barrierShape);
        barrierBody.position.set(posX, barrierHeight / 2, posZ);
        barrierBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle);
        world.addBody(barrierBody);
      }
    }

    // 기본 조명
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 200, 100);
    scene.add(dirLight);

    // 텍스처 및 재질 (기존 코드 활용 가능)

    // 플레이어 자동차, 바퀴, 물리 객체 선언
    let myCar = null;
    let chassisBody = null;
    let vehicle = null;

    // 바퀴 메시 배열
    const wheelMeshes = [];

    // 플레이어 닉네임 3D 텍스트
    const loaderFont = new THREE.FontLoader();
    let font = null;
    loaderFont.load('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json', (f) => {
      font = f;
    });

    function createNameTag(name) {
      if (!font) return null;
      const textGeo = new THREE.TextGeometry(name, {
        font: font,
        size: 0.7,
        height: 0.2,
        curveSegments: 3,
      });
      const textMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const textMesh = new THREE.Mesh(textGeo, textMat);
      textMesh.castShadow = false;
      textMesh.receiveShadow = false;
      return textMesh;
    }

    // 내 자동차 생성 함수
    function createMyCar(type, color) {
      if (vehicle) {
        // 기존 차량 및 물리 제거
        scene.remove(myCar);
        wheelMeshes.forEach(w => scene.remove(w));
        wheelMeshes.length = 0;
        world.bodies.forEach(b => {
          if (b === chassisBody || b.isWheel) {
            world.removeBody(b);
          }
        });
        vehicle = null;
      }

      // 물리 바디 생성 (기본 박스 차체 + 바퀴)
      chassisBody = new CANNON.Body({ mass: 1500 });
      chassisBody.position.set(500, 1, 15);
      const chassisShape = new CANNON.Box(new CANNON.Vec3(2, 0.5, 4));
      chassisBody.addShape(chassisShape);
      world.addBody(chassisBody);

      // 차량 메시 생성 (단순 박스 또는 실제 그랜저 IG 모양 등)
      if (type === 'GrandeurIG') {
        // 여기 사용자가 주신 그랜저 IG 모델링 함수 호출
        myCar = createGrandeurIGMesh(color);
      } else {
        // 기본 박스 차량
        const mat = new THREE.MeshStandardMaterial({ color: color });
        myCar = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 8), mat);
      }
      scene.add(myCar);

      // 바퀴 생성 (기존 바퀴 생성 로직 유지, 위치 조정 필요)
      for (let i = 0; i < 4; i++) {
        const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 24);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
        wheelMesh.rotation.z = Math.PI / 2;
        scene.add(wheelMesh);
        wheelMeshes.push(wheelMesh);
      }

      // 캐논 RaycastVehicle 세팅 (기존 구현 참고)
      vehicle = new CANNON.RaycastVehicle({
        chassisBody: chassisBody,
        indexRightAxis: 0,
        indexUpAxis: 1,
        indexForwardAxis: 2,
      });

      // 바퀴 위치 설정 (임의 예시)
      const wheelPositions = [
        new CANNON.Vec3(-1.5, 0, 3),
        new CANNON.Vec3(1.5, 0, 3),
        new CANNON.Vec3(-1.5, 0, -3),
        new CANNON.Vec3(1.5, 0, -3),
      ];
      for (let i = 0; i < 4; i++) {
        vehicle.addWheel({
          chassisConnectionPointLocal: wheelPositions[i],
          isFrontWheel: i < 2,
          suspensionRestLength: 0.3,
          suspensionStiffness: 30,
          maxSuspensionForce: 100000,
          maxSuspensionTravel: 0.3,
          dampingRelaxation: 2.3,
          dampingCompression: 4.4,
          frictionSlip: 3,
          rollInfluence: 0.01,
          axleLocal: new CANNON.Vec3(1, 0, 0),
          directionLocal: new CANNON.Vec3(0, -1, 0),
        });
      }
      vehicle.addToWorld(world);

      // 바퀴 물리-메시 동기화
      vehicle.wheelInfos.forEach((wheel, idx) => {
        wheelMeshes[idx].castShadow = true;
        wheelMeshes[idx].receiveShadow = true;
      });
    }

    // 간단한 그랜저 IG 모델링 함수 (예시)
    function createGrandeurIGMesh(color) {
      const group = new THREE.Group();
      // 차체
      const bodyMat = new THREE.MeshStandardMaterial({ color });
      const bodyGeom = new THREE.BoxGeometry(4, 1.5, 8);
      const bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
      group.add(bodyMesh);
      return group;
    }

    // 다른 플레이어 차량 (박스 + 닉네임) 생성
    function createOtherPlayerCar(name, color) {
      const group = new THREE.Group();
      const bodyMat = new THREE.MeshStandardMaterial({ color });
      const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 8), bodyMat);
      group.add(bodyMesh);
      const nameTag = createNameTag(name);
      if (nameTag) {
        nameTag.position.set(0, 2.5, 0);
        group.add(nameTag);
      }
      scene.add(group);
      return { group, nameTag };
    }

    // UI 요소
    const loginOverlay = document.getElementById('loginOverlay');
    const inputNickname = document.getElementById('inputNickname');
    const selectCarType = document.getElementById('selectCarType');
    const inputColor = document.getElementById('inputColor');
    const btnStart = document.getElementById('btnStart');

    // 자동차 조작 버튼 등 기존 요소들
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnAccel = document.getElementById('btnAccel');
    const btnBrake = document.getElementById('btnBrake');
    const btnReset = document.getElementById('btnReset');
    const btnToggleCam = document.getElementById('btnToggleCam');

    // 기존 조작 변수
    let isLeft = false, isRight = false, isAccel = false, isBrake = false;

    // 기존 버튼 이벤트
    btnLeft.addEventListener('mousedown', () => isLeft = true);
    btnLeft.addEventListener('mouseup', () => isLeft = false);
    btnLeft.addEventListener('touchstart', e => { e.preventDefault(); isLeft = true; });
    btnLeft.addEventListener('touchend', e => { e.preventDefault(); isLeft = false; });

    btnRight.addEventListener('mousedown', () => isRight = true);
    btnRight.addEventListener('mouseup', () => isRight = false);
    btnRight.addEventListener('touchstart', e => { e.preventDefault(); isRight = true; });
    btnRight.addEventListener('touchend', e => { e.preventDefault(); isRight = false; });

    btnAccel.addEventListener('mousedown', () => isAccel = true);
    btnAccel.addEventListener('mouseup', () => isAccel = false);
    btnAccel.addEventListener('touchstart', e => { e.preventDefault(); isAccel = true; });
    btnAccel.addEventListener('touchend', e => { e.preventDefault(); isAccel = false; });

    btnBrake.addEventListener('mousedown', () => isBrake = true);
    btnBrake.addEventListener('mouseup', () => isBrake = false);
    btnBrake.addEventListener('touchstart', e => { e.preventDefault(); isBrake = true; });
    btnBrake.addEventListener('touchend', e => { e.preventDefault(); isBrake = false; });

    btnReset.addEventListener('click', () => {
      if (chassisBody) {
        chassisBody.position.set(500, 1, 15);
        chassisBody.velocity.setZero();
        chassisBody.angularVelocity.setZero();
        chassisBody.quaternion.set(0, 0, 0, 1);
      }
    });

    // 카메라 모드 토글
    btnToggleCam.addEventListener('click', () => {
      cameraFollow = !cameraFollow;
      btnToggleCam.textContent = cameraFollow ? 'C: ON' : 'C: OFF';
    });

    // 게임 시작 함수
    function startGame() {
      const nickname = inputNickname.value.trim();
      if (!nickname) {
        alert('닉네임을 입력하세요.');
        return;
      }
      const carType = selectCarType.value;
      const carColor = inputColor.value;

      playerInfo = { nickname, carType, carColor };

      loginOverlay.style.display = 'none';

      // 내 차 생성
      createMyCar(carType, carColor);

      // 서버 연결 및 초기화
      socket = io();

      socket.on('connect', () => {
        myPlayerId = socket.id;
        socket.emit('newPlayer', { id: myPlayerId, ...playerInfo });
      });

      // 새 플레이어 접속
      socket.on('newPlayer', data => {
        if (data.id === myPlayerId) return;
        if (otherPlayers.has(data.id)) return;
        const otherCar = createOtherPlayerCar(data.nickname, data.carColor || '#ff0000');
        otherPlayers.set(data.id, { ...otherCar, id: data.id });
      });

      // 플레이어 위치 업데이트 받기
      socket.on('playerUpdate', data => {
        if (data.id === myPlayerId) return;
        const op = otherPlayers.get(data.id);
        if (!op) return;
        // 위치/회전 갱신
        op.group.position.set(data.position.x, data.position.y, data.position.z);
        op.group.quaternion.set(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w);
      });

      // 플레이어 퇴장 처리
      socket.on('playerDisconnect', id => {
        const op = otherPlayers.get(id);
        if (!op) return;
        scene.remove(op.group);
        otherPlayers.delete(id);
      });
    }

    btnStart.addEventListener('click', startGame);

    // 기존 애니메이션 루프 및 물리 업데이트
    const clock = new THREE.Clock();

    // 속도, 기어 UI 업데이트 (예시, 간단히)
    const hud = document.getElementById('hud');
    const gearDisplay = document.getElementById('gearDisplay');

    function updateHUD() {
      if (!vehicle) return;
      const speed = chassisBody.velocity.length();
      hud.textContent = `속도: ${ (speed * 3.6).toFixed(1) } km/h`;
      gearDisplay.textContent = `기어: ${currentGear}`;
    }

    // 기어 변수 (기존 로직 유지)
    let currentGear = 'P';

    // 기어 버튼 이벤트 (간단 예시)
    document.getElementById('gearP').addEventListener('click', () => currentGear = 'P');
    document.getElementById('gearR').addEventListener('click', () => currentGear = 'R');
    document.getElementById('gearN').addEventListener('click', () => currentGear = 'N');
    document.getElementById('gearD').addEventListener('click', () => currentGear = 'D');

    // 차량 조작 물리 반영 (간단 예시)
    function updateVehicleControls() {
      if (!vehicle) return;

      // 조향
      const maxSteerVal = 0.5;
      let steer = 0;
      if (isLeft) steer = maxSteerVal;
      else if (isRight) steer = -maxSteerVal;

      vehicle.setSteeringValue(steer, 0);
      vehicle.setSteeringValue(steer, 1);

      // 구동
      const maxForce = 5000;
      if (currentGear === 'D') {
        if (isAccel) {
          vehicle.applyEngineForce(-maxForce, 2);
          vehicle.applyEngineForce(-maxForce, 3);
        } else if (isBrake) {
          vehicle.setBrake(100, 2);
          vehicle.setBrake(100, 3);
        } else {
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        }
      } else if (currentGear === 'R') {
        if (isAccel) {
          vehicle.applyEngineForce(maxForce, 2);
          vehicle.applyEngineForce(maxForce, 3);
        } else if (isBrake) {
          vehicle.setBrake(100, 2);
          vehicle.setBrake(100, 3);
        } else {
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        }
      } else {
        vehicle.setBrake(100, 0);
        vehicle.setBrake(100, 1);
        vehicle.setBrake(100, 2);
        vehicle.setBrake(100, 3);
      }
    }

    // 차량 메시 위치/회전 업데이트
    function updateCarMeshes() {
      if (!vehicle) return;
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelMeshes[i].position.copy(t.position);
        wheelMeshes[i].quaternion.copy(t.quaternion);
      }
      if (!myCar) return;
      myCar.position.copy(chassisBody.position);
      myCar.quaternion.copy(chassisBody.quaternion);
    }

    // 내 위치를 서버에 보내기 (초당 20회)
    let lastSentTime = 0;
    function sendPlayerUpdate(delta) {
      if (!socket || !myPlayerId || !chassisBody) return;
      lastSentTime += delta;
      if (lastSentTime < 0.05) return; // 20fps

      lastSentTime = 0;
      socket.emit('playerUpdate', {
        id: myPlayerId,
        position: {
          x: chassisBody.position.x,
          y: chassisBody.position.y,
          z: chassisBody.position.z,
        },
        quaternion: {
          x: chassisBody.quaternion.x,
          y: chassisBody.quaternion.y,
          z: chassisBody.quaternion.z,
          w: chassisBody.quaternion.w,
        }
      });
    }

    // 메인 루프
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      if (vehicle) {
        updateVehicleControls();
        world.step(1/60, delta, 3);
        updateCarMeshes();
        updateHUD();
        sendPlayerUpdate(delta);
      }

      // 카메라 위치 조절 (플레이어 뒤따라가기 모드)
      if (cameraFollow && chassisBody) {
        const pos = chassisBody.position;
        const quat = chassisBody.quaternion;

        // 카메라 위치 계산
        const offset = new THREE.Vector3(0, 5, -10);
        offset.applyQuaternion(quat);

        camera.position.copy(pos).add(offset);
        camera.lookAt(pos);
      } else {
        // 자유 시점 카메라 업데이트
        const x = camDistance * Math.sin(camElevation) * Math.cos(camAzimuth);
        const y = camDistance * Math.cos(camElevation);
        const z = camDistance * Math.sin(camElevation) * Math.sin(camAzimuth);

        camera.position.set(x, y, z);
        camera.lookAt(0, 0, 0);
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
