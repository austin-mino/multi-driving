<!DOCTYPE html>
<html lang="ko">
<head>
  <link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>multi driving</title>
  
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
    /* ê¸°ì–´ ë²„íŠ¼ í¬ê¸° ì¡°ì ˆ */
#gearControls button.controlBtn {
  padding: 8px 12px;
  font-size: 14px;
}

/* ë¦¬ì…‹ ë²„íŠ¼ í¬ê¸° ì¡°ì ˆ */
#btnReset.controlBtn {
  padding: 8px 12px;
  font-size: 14px;
}
    #btnToggleCam {
  position: fixed;
  top: 10px;        /* ìœ„ì—ì„œë¶€í„° ê±°ë¦¬ ì¡°ì ˆ */
  right: 120px;      /* ì˜¤ë¥¸ìª½ì—ì„œë¶€í„° ê±°ë¦¬ */
  padding: 10px 14px; /* ë²„íŠ¼ í¬ê¸° ì¡°ì ˆ */
  font-size: 16px;    /* ê¸€ì í¬ê¸° */
  border-radius: 12px;
  background: #0078d7;
  color: white;
  border: none;
  cursor: pointer;
  z-index: 100;
  user-select: none;
  touch-action: manipulation;
  transition: background-color 0.2s, color 0.2s;
}

#btnToggleCam:active {
  background: #005a9e;
}
  </style>
  
   <script src="/socket.io/socket.io.js"></script>

   <!-- es-module-shims ë¡œë” -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

 <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/FontLoader.js",
      "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.152.2/examples/jsm/geometries/TextGeometry.js",
      "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
  }
  </script>
  
</head>
<body>
  <div id="startMenu" style="
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.85); padding: 30px; border-radius: 15px; z-index: 2000; color: white;
">
  <h2>ê²Œì„ ì‹œì‘</h2>
  <label>ë‹‰ë„¤ì„: <input type="text" id="nicknameInput" placeholder="Your Name" /></label><br /><br />
  <label>ì°¨ ìƒ‰ìƒ: <input type="color" id="colorInput" value="#ffffff" /></label><br /><br />
    <!-- ìë™ì°¨ ëª¨ë¸ ì„ íƒ -->
<label for="modelSelect">ìë™ì°¨ ëª¨ë¸ ì„ íƒ:</label>
<select id="modelSelect">
  <option value="GrandeurIG">ê·¸ëœì € IG</option>
  <option value="SportsCar">ìŠ¤í¬ì¸ ì¹´</option>
  <option value="SUV">SUV</option>
</select>
  <button id="startButton" style="padding: 10px 20px; font-size: 16px;">ê²Œì„ ì‹œì‘</button>
</div>

  <div id="rotateWarning">ê°€ë¡œ ëª¨ë“œë¡œ ì „í™˜í•´ì£¼ì„¸ìš”</div>
  <div id="hud">ì†ë„: 0 km/h</div>
  <div id="timerDisplay">íƒ€ì´ë¨¸: 0.00 s</div>
  <div id="gearDisplay">ê¸°ì–´: P</div>

  <!-- ì¢Œ/ìš° ìŠ¤í‹°ì–´ë§ -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">â—€</button>
    <button id="btnRight" class="controlBtn">â–¶</button>
  </div>
  <!-- ì—‘ì…€Â·ë¸Œë ˆì´í¬ -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">accel</button>
    <button id="btnBrake" class="controlBtn">brake</button>
  <div id="reset">
    <!-- ê¸°ì–´ ì„ íƒ ì•„ë˜ì— ì¶”ê°€ -->
    <button id="btnReset" class="controlBtn">ë¦¬ì…‹</button>
  </div>
    <!-- ê¸°ì–´ ì„ íƒ -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

    <!-- ì¹´ë©”ë¼ í† ê¸€ ë²„íŠ¼ -->
<button id="btnToggleCam" class="controlBtn">C: ON</button>

<script type="module">
import * as THREE from 'three';
import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/geometries/TextGeometry.js';
import { RoundedBoxGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/geometries/RoundedBoxGeometry.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    const socket = io('https://multi-driving.onrender.com'); // â† ì—¬ê¸°ì— ë°°í¬ ì£¼ì†Œ ì •í™•íˆ ê¸°ì…
    document.getElementById('startButton').addEventListener('click', () => {
  const nickname = document.getElementById('nicknameInput').value.trim();
  const modelName = document.getElementById('modelSelect').value || 'GrandeurIG';
  const color = document.getElementById('colorInput').value || '#ffffff';
  if (!nickname) {
    alert('ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”!');
    return;
  }

document.getElementById('startMenu').style.display = 'none';

  startGame(modelName, color, nickname);
});

let font;
const fontLoader = new FontLoader();
fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json', loadedFont => {
  font = loadedFont;
});

    // ê°€ë¡œëª¨ë“œ ì²´í¬
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Three.js ê¸°ë³¸ ì„¤ì •
    const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0a0a0);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
camera.position.set(0, 300, 500);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
    // ììœ  ì¹´ë©”ë¼ ê°ë„ ë³€ìˆ˜ (êµ¬ë©´ì¢Œí‘œ)
// ì´ˆê¸° ê°ë„ëŠ” ë’¤ìª½ ì•½ê°„ ìœ„ì—ì„œ ë°”ë¼ë³´ëŠ” ëŠë‚Œìœ¼ë¡œ ì„¤ì •
let camAzimuth = Math.PI;       // ì¢Œìš° íšŒì „ (0~2PI)
let camElevation = Math.PI / 6; // ìœ„ì•„ë˜ íšŒì „ (0~PI, 0:ìœ„, PI:ì•„ë˜)

// ì¹´ë©”ë¼ì™€ ìë™ì°¨ ì‚¬ì´ ê±°ë¦¬
const camDistance = 15;

// ë§ˆìš°ìŠ¤/í„°ì¹˜ ë“œë˜ê·¸ ìƒíƒœ ì €ì¥
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let camAzimuthStart = camAzimuth;
let camElevationStart = camElevation;

// ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
function onPointerDown(event) {
  if (!cameraFollow) {
    isDragging = true;
    dragStart.x = event.clientX;
    dragStart.y = event.clientY;
    camAzimuthStart = camAzimuth;
    camElevationStart = camElevation;
  }
}
function onPointerMove(event) {
  if (isDragging && !cameraFollow) {
    const deltaX = event.clientX - dragStart.x;
    const deltaY = event.clientY - dragStart.y;

    // íšŒì „ ì†ë„ ì¡°ì ˆ (ì ë‹¹íˆ ì¡°ì • ê°€ëŠ¥)
    const rotationSpeed = 0.05

    camAzimuth = camAzimuthStart - deltaX * rotationSpeed;
    camElevation = camElevationStart - deltaY * rotationSpeed;

    // camElevation ì œí•œ (0.1 ~ PI-0.1)ìœ¼ë¡œ ë„ˆë¬´ ìœ„ì•„ë˜ ì œí•œ
    camElevation = Math.min(Math.max(camElevation, 0.1), Math.PI - 0.1);
  }
}
function onPointerUp(event) {
  isDragging = false;
}

// í„°ì¹˜ ì´ë²¤íŠ¸ë„ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
renderer.domElement.addEventListener('pointerdown', onPointerDown);
renderer.domElement.addEventListener('pointermove', onPointerMove);
renderer.domElement.addEventListener('pointerup', onPointerUp);
renderer.domElement.addEventListener('pointerleave', onPointerUp);
renderer.domElement.addEventListener('touchcancel', onPointerUp);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
document.getElementById('btnReset').addEventListener('click', resetCar);
window.addEventListener('keydown', e => {
  if (e.key?.toLowerCase() === 'r') resetCar();
});

function resetCar() {
  // ìœ„ì¹˜ëŠ” ê·¸ëŒ€ë¡œ, ë†’ì´ ì•½ê°„ ìœ„ë¡œ
  const pos = chassisBody.position;
  chassisBody.position.set(pos.x, pos.y + 1.5, pos.z);

  // íšŒì „ ì´ˆê¸°í™” (yì¶•ì€ ìœ ì§€í•´ì„œ ë°©í–¥ì€ ê·¸ëŒ€ë¡œ)
  const yRot = getYRotation(chassisBody.quaternion);
  chassisBody.quaternion.setFromEuler(0, yRot, 0);

  // ì†ë„ ì´ˆê¸°í™”
  chassisBody.velocity.set(0, 0, 0);
  chassisBody.angularVelocity.set(0, 0, 0);
}

// ì¿¼í„°ë‹ˆì–¸ì—ì„œ yì¶• íšŒì „ê°’ ì¶”ì¶œ
function getYRotation(q) {
  const siny_cosp = 2 * (q.w * q.y + q.z * q.x);
  const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
  return Math.atan2(siny_cosp, cosy_cosp);
}

// 1. ë¬¼ë¦¬ ì›”ë“œ ìƒì„±
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0),
});

// 2. Three.js ë°”ë‹¥ (ë„ë¡œ ë°‘ ë°”ë‹¥)
const floorGeo = new THREE.PlaneGeometry(10000, 10000);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
const floorMesh = new THREE.Mesh(floorGeo, floorMat);
floorMesh.rotation.x = -Math.PI / 2;
floorMesh.position.y = -5;
scene.add(floorMesh);
floorMesh.receiveShadow = true;

// 3. Cannon-es ë°”ë‹¥ ë¬¼ë¦¬
const floorBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  position: new CANNON.Vec3(0, -5.4, 0),
});
floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(floorBody);

// 4. ë„ì‹œ ìƒì„± ê¸°ë³¸ ì„¤ì •
const BLOCK_SIZE = 100;
const ROAD_WIDTH = 20;
const SIDEWALK_WIDTH = 12; // ì¸ë„ í­ ì‚´ì§ í‚¤ì›€
const BUILDING_AREA = BLOCK_SIZE - ROAD_WIDTH - SIDEWALK_WIDTH * 2;
const GRID_COUNT = 5;

const COLORS = {
  road: 0x000000,
  sidewalk: 0xcccccc,    // ì—°í•œ íšŒìƒ‰ ì¸ë„ë¡œ ë³€ê²½
  grass: 0x228B22,
  building: [0x444444, 0x777777, 0xaaaaaa, 0xffffff]  // í°ìƒ‰ ì¶”ê°€
};

// ê·¸ë£¹
const roadGroup = new THREE.Group();
const buildingGroup = new THREE.Group();
const parkGroup = new THREE.Group();
scene.add(roadGroup, buildingGroup, parkGroup);

// 5. ë¸”ë¡ ìƒì„±
for (let i = -GRID_COUNT; i <= GRID_COUNT; i++) {
  for (let j = -GRID_COUNT; j <= GRID_COUNT; j++) {
    const x = i * BLOCK_SIZE;
    const z = j * BLOCK_SIZE;

    createRoadBlock(x, z);
    createSidewalk(x, z);
    
    const isPark = Math.random() < 0.1;
    if (isPark) createPark(x, z);
    else createBuilding(x, z);
  }
}

// 6. í•¨ìˆ˜ ì •ì˜

function createRoadBlock(x, z) {
  const geo = new THREE.BoxGeometry(BLOCK_SIZE, 0, BLOCK_SIZE);
  const mat = new THREE.MeshStandardMaterial({ color: COLORS.road });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, -5, z);
  mesh.receiveShadow = true;
  roadGroup.add(mesh);
}

function createSidewalk(x, z) {
  const size = BLOCK_SIZE - ROAD_WIDTH;
  const geo = new THREE.BoxGeometry(size, 0.008, size);
  const mat = new THREE.MeshStandardMaterial({ color: COLORS.sidewalk });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, -5.001, z);
  mesh.receiveShadow = true;
  roadGroup.add(mesh);
}

function createBuilding(x, z) {
  const w = THREE.MathUtils.randFloat(20, BUILDING_AREA);
  const d = THREE.MathUtils.randFloat(20, BUILDING_AREA);
  const h = THREE.MathUtils.randFloat(40, 100);
  const color = COLORS.building[Math.floor(Math.random() * COLORS.building.length)];

  // Three.js ë©”ì‰¬
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, -4.8 + h / 2, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  buildingGroup.add(mesh);

  // Cannon-es ë¬¼ë¦¬ ë°”ë”” (ë°•ìŠ¤ ëª¨ì–‘)
  const shape = new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2));
  const body = new CANNON.Body({ mass: 0, shape });
  body.position.set(x, -4.8 + h / 2, z);
  world.addBody(body);
  addPropsAroundBuilding(x, z, w, d);
}

function createPark(x, z) {
  const geo = new THREE.PlaneGeometry(BLOCK_SIZE - 10, BLOCK_SIZE - 10);
  const mat = new THREE.MeshStandardMaterial({ color: COLORS.grass, side: THREE.DoubleSide });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.set(x, -4.94, z);
  mesh.receiveShadow = true;
  parkGroup.add(mesh);
}

// 7. í•˜ëŠ˜ìƒ‰ ë°°ê²½ ì„¤ì •
scene.background = new THREE.Color(0x87ceeb); // í•˜ëŠ˜ìƒ‰ (skyblue)

  const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(100, 200, 100);
light.castShadow = true;

// ê·¸ë¦¼ì í’ˆì§ˆ ì„¤ì •
light.shadow.mapSize.width = 2048;
light.shadow.mapSize.height = 2048;
light.shadow.camera.near = 0.5;
light.shadow.camera.far = 1000;
light.shadow.camera.left = -500;
light.shadow.camera.right = 500;
light.shadow.camera.top = 500;
light.shadow.camera.bottom = -500;

scene.add(light);

// Ambient Light ì¶”ê°€
scene.add(new THREE.AmbientLight(0x404040));

 function addPropsAroundBuilding(x, z, w, d) {
  const propsGroup = new THREE.Group();

  const sidewalkRange = BLOCK_SIZE / 2 - SIDEWALK_WIDTH / 2;

  const benchGeo = new THREE.BoxGeometry(4, 0.5, 1);
  const benchMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

  const lightGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
  const lightMat = new THREE.MeshStandardMaterial({ color: 0x888888 });

  const treeGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 6);
  const treeTopGeo = new THREE.SphereGeometry(1.5, 8, 8);
  const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const treeTopMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });

  const offsets = [
    [w / 2 + 2, d / 2 + 2],
    [-w / 2 - 2, d / 2 + 2],
    [w / 2 + 2, -d / 2 - 2],
    [-w / 2 - 2, -d / 2 - 2],
  ];

  for (const [dx, dz] of offsets) {
    const px = x + dx;
    const pz = z + dz;

    // ì¸ë„ ì˜ì—­ ì•ˆì—ë§Œ ë°°ì¹˜ (BLOCK_SIZE/2 ê¸°ì¤€)
    const localX = px % BLOCK_SIZE;
    const localZ = pz % BLOCK_SIZE;

    if (Math.abs(localX) > sidewalkRange || Math.abs(localZ) > sidewalkRange) continue;

    const rand = Math.random();
    if (rand < 0.33) {
      const bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(px, -4.75, pz);
      bench.castShadow = true;
      propsGroup.add(bench);
    } else if (rand < 0.66) {
      const light = new THREE.Mesh(lightGeo, lightMat);
      light.position.set(px, -2.5, pz);
      light.castShadow = true;
      propsGroup.add(light);
    } else {
      const trunk = new THREE.Mesh(treeGeo, treeTrunkMat);
      trunk.position.set(px, -3.0, pz);
      const top = new THREE.Mesh(treeTopGeo, treeTopMat);
      top.position.set(px, 0, pz);

      trunk.castShadow = true;
      top.castShadow = true;
      propsGroup.add(trunk);
      propsGroup.add(top);
    }
  }
  scene.add(propsGroup);
}

    // ìë™ì°¨ ì°¨ì²´ ë¬¼ë¦¬ (ë°•ìŠ¤)
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
    const chassisBody = new CANNON.Body({ mass: 110 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(-38, 0.7, 0);
    chassisBody.angularDamping = 0.5;
    chassisBody.linearDamping = 0.0;
    world.addBody(chassisBody);
  let carModel; // ì„ ì–¸ë§Œ


    // ìë™ì°¨ ì‹œê° ëª¨ë¸ (ë‘¥ê·¼ ì°¨ì²´)
    function createGrandeurIGCarDetailed(color = '#ffffff') {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.4 });
  const mainBody = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 6), bodyMat);
  mainBody.name = 'MainBody';
  mainBody.userData.physics = {
  mass: 1500,
  shape: new CANNON.Box(new CANNON.Vec3(1.5, 0.6, 3))  // half extents
};
  mainBody.position.y = 0.6;
  group.add(mainBody);

  const sphereGeom = new THREE.SphereGeometry(0.6, 16, 16);
  [[-1.2, 0.6, -2.7], [1.2, 0.6, -2.7], [-1.2, 0.6, 2.7], [1.2, 0.6, 2.7]].forEach(([x,y,z])=>{
    const s = new THREE.Mesh(sphereGeom, bodyMat);
    s.position.set(x, y, z);
    group.add(s);
  });

  const roof = new THREE.Mesh(
    new THREE.BoxGeometry(2.5, 0.4, 3),
    new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5, roughness: 0.5 })
  );
  roof.position.set(0, 1.3, 0);
  group.add(roof);

  const windowMat = new THREE.MeshStandardMaterial({ color: 0x446688, transparent: true, opacity: 0.5, roughness: 0.1 });
  const frontWin = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.5, 0.05), windowMat);
  frontWin.position.set(0, 1.25, -1.5);
  group.add(frontWin);

  const rearWin = frontWin.clone();
  rearWin.position.z = 1.5;
  group.add(rearWin);

  const leftWin = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.5, 3), windowMat);
  leftWin.position.set(-1.25, 1.25, 0);
  group.add(leftWin);

  const rightWin = leftWin.clone();
  rightWin.position.x = 1.25;
  group.add(rightWin);

  const bumperMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
  const fBump = new THREE.Mesh(new THREE.BoxGeometry(3, 0.6, 0.5), bumperMat);
  fBump.position.set(0, 0.5, -3.1);
  group.add(fBump);

  const rBump = fBump.clone();
  rBump.position.z = 3.1;
  group.add(rBump);

  const headMat = new THREE.MeshStandardMaterial({
  color: 0xffffee,
  emissive: 0xffffee,
  emissiveIntensity: 0.7,
  roughness: 0.3
});

// ì™¼ìª½ í—¤ë“œë¼ì´íŠ¸ (ê°€ë¡œë¡œ ê¸¸ê³  ë‚©ì‘í•œ ë°•ìŠ¤)
const headLamp = new THREE.Mesh(
  new THREE.BoxGeometry(0.8, 0.2, 0.1),  // X: ê°€ë¡œê¸¸ì´, Y: ë†’ì´, Z: ë‘ê»˜
  headMat
);
headLamp.position.set(-1.1, 0.65, -3.35);  // ìœ„ì¹˜: ì™¼ìª½ ì•„ë˜ ì•ìª½
group.add(headLamp);

// ì˜¤ë¥¸ìª½ í—¤ë“œë¼ì´íŠ¸
const headLampR = headLamp.clone();
headLampR.position.x = 1.1;
group.add(headLampR);

  // âœ… ì‚¬ì´ë“œë¯¸ëŸ¬ ì¶”ê°€
  const mirrorMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  for (let side of [-1, 1]) {
    const mirror = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.5), mirrorMat);
    mirror.position.set(side * 1.6, 1.2, -1.8);
    mirror.rotation.y = side * Math.PI / 8;
    group.add(mirror);
  }

  // âœ… í›„ë¯¸ë“± ì¶”ê°€
  const tailMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0xff3333, emissiveIntensity: 0.6 });
const tailBar = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 0.05), tailMat);
tailBar.position.set(0, 0.85, 3.3);  // ì°¨ ë’·ë¶€ë¶„, ì¤‘ì‹¬ ìœ„ì¹˜
group.add(tailBar);

  return group;
}

function createSportsCar(color = '#ffffff') {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.4 });
  // ë©”ì¸ ì°¨ì²´ ë†’ì´ 1.2 -> 1.0, ìœ„ì¹˜ y 0.6 -> 0.55 (ì•½ê°„ ë‚®ê²Œ)
  const mainBody = new THREE.Mesh(new THREE.BoxGeometry(3, 1.0, 6), bodyMat);
  mainBody.name = 'MainBody';
  mainBody.userData.physics = {
  mass: 1200,
  shape: new CANNON.Box(new CANNON.Vec3(1.5, 0.6, 3))  // half extents
};
  mainBody.position.y = 0.55;
  group.add(mainBody);

  const sphereGeom = new THREE.SphereGeometry(0.6, 16, 16);
  // êµ¬ ìœ„ì¹˜ yë„ 0.6 -> 0.55ë¡œ ë§ì¶¤
  [[-1.2, 0.55, -2.7], [1.2, 0.55, -2.7], [-1.2, 0.55, 2.7], [1.2, 0.55, 2.7]].forEach(([x,y,z])=>{
    const s = new THREE.Mesh(sphereGeom, bodyMat);
    s.position.set(x, y, z);
    group.add(s);
  });

  // ë£¨í”„ ë†’ì´ 0.4 -> 0.3, ìœ„ì¹˜ y 1.3 -> 1.1, ì•½ê°„ ì•ìœ¼ë¡œ ê¸°ìš¸ì„
  const roof = new THREE.Mesh(
    new THREE.BoxGeometry(2.5, 0.3, 3),
    new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5, roughness: 0.5 })
  );
  roof.position.set(0, 1.1, 0);
  roof.rotation.x = -Math.PI / 180 * 10;  // -10ë„ ì•ìª½ìœ¼ë¡œ ê¸°ìš¸ì„
  group.add(roof);

  // ìœ ë¦¬ì°½ ì¬ì§ˆ
  const windowMat = new THREE.MeshStandardMaterial({ color: 0x446688, transparent: true, opacity: 0.5, roughness: 0.1 });

  // ì• ìœ ë¦¬ì°½, ë†’ì´ 1.25 -> 1.05, ìœ„ì¹˜ ê·¸ëŒ€ë¡œ, ì•ìª½ìœ¼ë¡œ ê¸°ìš¸ì„
  const frontWin = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.5, 0.05), windowMat);
  frontWin.position.set(0, 1.05, -1.5);
  frontWin.rotation.x = -Math.PI / 9;  // ì•½ -20ë„ ê¸°ìš¸ì„
  group.add(frontWin);

  // ë’¤ ìœ ë¦¬ì°½, ìœ„ì¹˜ y 1.25 -> 1.05, ë’¤ìª½ìœ¼ë¡œ ì•½ê°„ ì –í˜
  const rearWin = frontWin.clone();
  rearWin.position.z = 1.5;
  rearWin.rotation.x = Math.PI / 12;
  group.add(rearWin);

  // ì¢Œìš° ìœ ë¦¬ì°½ ë†’ì´ 1.25 -> 1.05
  const leftWin = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.5, 3), windowMat);
  leftWin.position.set(-1.25, 1.05, 0);
  group.add(leftWin);

  const rightWin = leftWin.clone();
  rightWin.position.x = 1.25;
  group.add(rightWin);

  // ì• ë²”í¼ ë†’ì´ 0.6 -> 0.45, ìœ„ì¹˜ y 0.5 -> 0.4
  const bumperMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
  const fBump = new THREE.Mesh(new THREE.BoxGeometry(3, 0.45, 0.5), bumperMat);
  fBump.position.set(0, 0.4, -3.1);
  group.add(fBump);

  // ë’¤ ë²”í¼ë„ y 0.4ë¡œ ë§ì¶¤
  const rBump = fBump.clone();
  rBump.position.z = 3.1;
  group.add(rBump);

  // í—¤ë“œë¼ì´íŠ¸ ë†’ì´ 0.65 -> 0.5
  const headMat = new THREE.MeshStandardMaterial({
    color: 0xffffee,
    emissive: 0xffffee,
    emissiveIntensity: 0.7,
    roughness: 0.3
  });

  const headLamp = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 0.2, 0.1),
    headMat
  );
  headLamp.position.set(-1.1, 0.5, -3.35);
  group.add(headLamp);

  const headLampR = headLamp.clone();
  headLampR.position.x = 1.1;
  group.add(headLampR);

  // ì‚¬ì´ë“œë¯¸ëŸ¬ ë†’ì´ 1.2 -> 1.0
  const mirrorMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  for (let side of [-1, 1]) {
    const mirror = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.5), mirrorMat);
    mirror.position.set(side * 1.6, 1.0, -1.8);
    mirror.rotation.y = side * Math.PI / 8;
    group.add(mirror);
  }

  // í›„ë¯¸ë“± ë†’ì´ 0.85 -> 0.65
  const tailMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0xff3333, emissiveIntensity: 0.6 });
  const tailBar = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 0.05), tailMat);
  tailBar.position.set(0, 0.65, 3.3);
  group.add(tailBar);

  return group;
}

function createSUVCar(color = '#ffffff') {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({ color, metalness: 0.7, roughness: 0.3 });

  // RoundedBoxGeometry: ë„ˆë¹„ 3.5, ë†’ì´ 1.6, ê¹Šì´ 6, ê³¡ë¥  0.3, 5ë¶„í• 
  const mainBody = new THREE.Mesh(
    new RoundedBoxGeometry(3.5, 1.6, 6, 5, 0.3),
    bodyMat
  );
  mainBody.name = 'MainBody';
  mainBody.userData.physics = {
  mass: 2000,
  shape: new CANNON.Box(new CANNON.Vec3(1.5, 0.6, 3))  // half extents
};
  mainBody.position.y = 0.8;  // ì°¨ì²´ ë†’ì´ ì ˆë°˜
  group.add(mainBody);

  // ë£¨í”„: ë‚ ë µí•˜ê²Œ ì•ìª½ìœ¼ë¡œ ë‚®ì¶”ê³  ë’¤ë¡œ ì•½ê°„ ì˜¬ë¼ê° (BoxGeometryë¥¼ Rotate í•˜ë©´ì„œ ì¡°ì •)
  const roofMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.5, roughness: 0.4 });
  const roof = new THREE.Mesh(
    new RoundedBoxGeometry(3.2, 0.4, 4, 4, 0.2),
    roofMat
  );
  roof.position.set(0, 1.3, 0);
  roof.rotation.x = -Math.PI / 12;  // ì•½ -15ë„ ê¸°ìš¸ì„
  group.add(roof);

  // ì°½ë¬¸ ì¬ì§ˆê³¼ íˆ¬ëª…ë„
  const windowMat = new THREE.MeshStandardMaterial({ color: 0x335577, transparent: true, opacity: 0.4, roughness: 0.1 });

  // ì• ìœ ë¦¬ì°½: ì–‡ê³  ì•½ê°„ ê¸°ìš¸ì„, ìœ„ì¹˜ ì•ìª½ (ì•ìœ ë¦¬ ëŠë‚Œ)
  const frontWin = new THREE.Mesh(
    new RoundedBoxGeometry(3, 0.5, 0.1, 3, 0.1),
    windowMat
  );
  frontWin.position.set(0, 1.2, -1.9);
  frontWin.rotation.x = -Math.PI / 6;  // -30ë„ ê¸°ìš¸ì„
  group.add(frontWin);

  // ë’¤ ìœ ë¦¬ì°½: ì•ìª½ë³´ë‹¨ ì‚´ì§ ì„¸ìš°ê³  ìœ„ì¹˜ ë’¤ìª½
  const rearWin = new THREE.Mesh(
    new RoundedBoxGeometry(3, 0.5, 0.1, 3, 0.1),
    windowMat
  );
  rearWin.position.set(0, 1.1, 1.7);
  rearWin.rotation.x = Math.PI / 12;  // ì•½ 15ë„ ë’¤ë¡œ ì –í˜
  group.add(rearWin);

  // ì¢Œìš° ìœ ë¦¬ì°½: ê¸¸ê³  ì–‡ê²Œ
  const sideWinLeft = new THREE.Mesh(
    new RoundedBoxGeometry(0.1, 0.5, 3.6, 3, 0.1),
    windowMat
  );
  sideWinLeft.position.set(-1.7, 1.15, 0);
  group.add(sideWinLeft);

  const sideWinRight = sideWinLeft.clone();
  sideWinRight.position.x = 1.7;
  group.add(sideWinRight);

  // ì• ë²”í¼: RoundedBoxGeometry, ë‚®ê²Œ ë¶™ì„
  const bumperMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.25 });
  const frontBumper = new THREE.Mesh(
    new RoundedBoxGeometry(3.5, 0.5, 0.6, 3, 0.15),
    bumperMat
  );
  frontBumper.position.set(0, 0.45, -3.3);
  group.add(frontBumper);

  // ë’¤ ë²”í¼ë„ ìœ ì‚¬í•˜ê²Œ
  const rearBumper = frontBumper.clone();
  rearBumper.position.z = 3.3;
  group.add(rearBumper);

  // í—¤ë“œë¼ì´íŠ¸: ë‚©ì‘í•œ ë°•ìŠ¤í˜•íƒœ, ìœ„ì¹˜ë„ ë‚®ê³  ì˜†ìœ¼ë¡œ ê¸¸ê²Œ
  const headMat = new THREE.MeshStandardMaterial({
    color: 0xffffee,
    emissive: 0xffffee,
    emissiveIntensity: 0.8,
    roughness: 0.3
  });

  const headLampL = new THREE.Mesh(
    new RoundedBoxGeometry(0.9, 0.25, 0.1, 3, 0.05),
    headMat
  );
  headLampL.position.set(-1.3, 0.55, -3.55);
  group.add(headLampL);

  const headLampR = headLampL.clone();
  headLampR.position.x = 1.3;
  group.add(headLampR);

  // ì‚¬ì´ë“œë¯¸ëŸ¬: ê°ì§€ê³  ë‚ ë µí•˜ê²Œ
  const mirrorMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5, roughness: 0.3 });
  for (let side of [-1, 1]) {
    const mirror = new THREE.Mesh(new RoundedBoxGeometry(0.45, 0.15, 0.35, 2, 0.05), mirrorMat);
    mirror.position.set(side * 1.8, 1.3, -1.6);
    mirror.rotation.y = side * Math.PI / 10;
    group.add(mirror);
  }

  // í›„ë¯¸ë“±: ë„“ê³  ì–‡ê²Œ, ìœ„ì¹˜ ë†’ìŒ
  const tailMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.7 });
  const tailLight = new THREE.Mesh(
    new RoundedBoxGeometry(2.8, 0.2, 0.07, 3, 0.1),
    tailMat
  );
  tailLight.position.set(0, 1.0, 3.4);
  group.add(tailLight);

  return group;
}
      
    // ì°¨ëŸ‰ìš© RaycastVehicle ì„¤ì •
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody,
      indexRightAxis: 0, // xì¶•ì´ ì°¨ëŸ‰ ì˜¤ë¥¸ìª½
      indexUpAxis: 1,    // yì¶•ì´ ìœ„
      indexForwardAxis: 2, // zì¶•ì´ ì•ìª½
    });

    // íœ  ì˜µì…˜ - ë””ìì¸ ë° ë¬¼ë¦¬ ì¡°ì •
    const wheelOptions = {
      radius: 0.46,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 45,
      suspensionRestLength: 0.4,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 1e4,
      rollInfluence: 0.02,
      axleLocal: new CANNON.Vec3(1, 0, 0),
      maxSuspensionTravel: 0.3,
      useCustomSlidingRotationalSpeed: true,
      customSlidingRotationalSpeed: -30,
    };

    // íœ  ìœ„ì¹˜ ë° ì•ë°”í€´ ì—¬ë¶€ ì„¤ì •
    [[-1.2, 0.2, 2.4, true], [1.2, 0.2, 2.4, true], [-1.2, 0.2, -2.4, false], [1.2, 0.2, -2.4, false]].forEach(
      ([x, y, z, isFront]) => {
        vehicle.addWheel({
          ...wheelOptions,
          chassisConnectionPointLocal: new CANNON.Vec3(x, y, z),
          isFrontWheel: isFront,
        });
      }
    );

    vehicle.addToWorld(world);

    // íœ  ë©”ì‹œ ìƒì„± - ì‹¤ì œ íƒ€ì´ì–´ ëª¨ì–‘ì— ê°€ê¹ê²Œ ë””ìì¸ ë° ê°ë„ ì¡°ì •
    const wheelHolders = [];
    vehicle.wheelInfos.forEach((wheel) => {
      const holder = new THREE.Group();
      scene.add(holder);
      wheelHolders.push(holder);

      const tireGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 24);
      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.4 });
      const tireMesh = new THREE.Mesh(tireGeo, tireMat);
      tireMesh.rotation.z = Math.PI / 2; // ëˆ•íˆê¸°
      holder.add(tireMesh);
    });
  
// ì‚¬ìš©ì ì…ë ¥ ìƒíƒœ
let input = { left: false, right: false, accel: false, brake: false };

    
    // DOM ìš”ì†Œ ë°”ì¸ë”©
    const btnLeft = document.getElementById('btnLeft'),
          btnRight = document.getElementById('btnRight'),
          btnAccel = document.getElementById('btnAccel'),
          btnBrake = document.getElementById('btnBrake'),
          gearDisplay = document.getElementById('gearDisplay'),
          gearButtons = [...document.querySelectorAll('#gearControls button')],
          hud = document.getElementById('hud'),
          timerDisplay = document.getElementById('timerDisplay');
// ì¹´ë©”ë¼ ì¶”ì  ON/OFF ìƒíƒœ ë³€ìˆ˜
let cameraFollow = true;

// í† ê¸€ ë²„íŠ¼ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
const btnToggleCam = document.getElementById('btnToggleCam');

// ë²„íŠ¼ í´ë¦­ ì‹œ í† ê¸€ ë° í…ìŠ¤íŠ¸ ë³€ê²½
btnToggleCam.addEventListener('click', () => {
  cameraFollow = !cameraFollow;
  btnToggleCam.textContent = `C: ${cameraFollow ? 'ON' : 'OFF'}`;
});
    // ì´ˆê¸° ê¸°ì–´ ìƒíƒœ
    let gearState = 'P';

    // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
    window.addEventListener('keydown', e => {
      const key = (e.key ||'').toLowerCase();
      switch(key) {
        case 'arrowleft':
        case 'a': input.left = true; break;
        case 'arrowright':
        case 'd': input.right = true; break;
        case 'arrowup':
        case 'w': input.accel = true; break;
        case 'arrowdown':
        case 's': input.brake = true; break;
        case '1': setGear('P'); break;
        case '2': setGear('R'); break;
        case '3': setGear('N'); break;
        case '4': setGear('D'); break;
      }
    });

    window.addEventListener('keyup', e => {
      const key = (e.key||'').toLowerCase();
      switch(key) {
        case 'arrowleft':
        case 'a': input.left = false; break;
        case 'arrowright':
        case 'd': input.right = false; break;
        case 'arrowup':
        case 'w': input.accel = false; break;
        case 'arrowdown':
        case 's': input.brake = false; break;
        case 'c': btnToggleCam.click(); break;
      }
    });

    // ëª¨ë°”ì¼ ë²„íŠ¼ ë°”ì¸ë”© í•¨ìˆ˜
    function bindButton(button, prop) {
      const setTrue = e => { e.preventDefault(); input[prop] = true; };
      const setFalse = e => { e.preventDefault(); input[prop] = false; };
      button.addEventListener('mousedown', setTrue);
      button.addEventListener('mouseup', setFalse);
      button.addEventListener('touchstart', setTrue, { passive: false });
      button.addEventListener('touchend', setFalse, { passive: false });
      button.addEventListener('touchcancel', setFalse, { passive: false });
    }

    bindButton(btnLeft, 'left');
    bindButton(btnRight, 'right');
    bindButton(btnAccel, 'accel');
    bindButton(btnBrake, 'brake');

    // ë¸Œë ˆì´í¬ í•¨ìˆ˜
    function applyBrake(force) {
      for(let i=0; i<4; i++) vehicle.setBrake(force, i);
    }

    // ê¸°ì–´ ìƒíƒœì™€ UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    const maxEngineForce = 1200;
    const maxBrakeForce = 30;
    const maxSteerVal = Math.PI / 8;
    let engineForce = 0;
    let steeringValue = 0;

    function updateGearDisplay() {
      gearDisplay.textContent = `ê¸°ì–´: ${gearState}`;
      const colorMap = { P: '#00ffff', R: '#ff5555', N: '#ffff55', D: '#55ff55' };
      gearDisplay.style.color = colorMap[gearState] || '#fff';
    }
    function setGear(gear) {
      gearState = gear;
      updateGearDisplay();
    }

    gearButtons.forEach(button => {
      button.addEventListener('click', () => setGear(button.textContent));
    });

    // ì°¨ëŸ‰ ì¡°í–¥, ê°€ì†, ë¸Œë ˆì´í¬ ì²˜ë¦¬
    function updateVehicleControls() {
      // ì¡°í–¥: ì¢Œìš° í‚¤ ë˜ëŠ” ë²„íŠ¼ì— ë”°ë¼ steeringValue ì¡°ì ˆ
      const steerSpeed = 0.01;  // ì¡°í–¥ì´ ë³€í™”í•˜ëŠ” ì†ë„ (ë” ì‘ì„ìˆ˜ë¡ ëŠë¦¬ê²Œ ë°˜ì‘)

if (input.left) {
  steeringValue = Math.max(steeringValue - steerSpeed, -maxSteerVal);
} else if (input.right) {
  steeringValue = Math.min(steeringValue + steerSpeed, maxSteerVal);
} else {
  // ì¤‘ë¦½ ë°©í–¥ìœ¼ë¡œ ì²œì²œíˆ ë³µê·€
  if (steeringValue > 0) steeringValue = Math.max(steeringValue - steerSpeed, 0);
  else if (steeringValue < 0) steeringValue = Math.min(steeringValue + steerSpeed, 0);
}

      // ì•ë°”í€´ ì¡°í–¥ì— ì ìš©
      vehicle.setSteeringValue(steeringValue, 0);
      vehicle.setSteeringValue(steeringValue, 1);

      vehicle.setSteeringValue(0, 2); // ë’·ì™¼ìª½ ë°”í€´ â†’ ì¡°í–¥ ì—†ìŒ
      vehicle.setSteeringValue(0, 3); // ë’·ì˜¤ë¥¸ìª½ ë°”í€´ â†’ ì¡°í–¥ ì—†ìŒ
      // ì—”ì§„ í˜ ì´ˆê¸°í™”
      engineForce = 0;

      // ê¸°ì–´ë³„ í˜ ì „ë‹¬
      if (gearState === 'D') {
        if (input.accel) engineForce = maxEngineForce;
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'R') {
        if (input.accel) engineForce = -maxEngineForce * 0.6; // í›„ì§„ì€ í˜ ì•½ê°„ ì¤„ì„
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'N') {
        applyBrake(input.brake ? maxBrakeForce : 0);
        engineForce = 0;
      } else if (gearState === 'P') {
        applyBrake(maxBrakeForce * 1.5); // ì£¼ì°¨ë¸Œë ˆì´í¬ ê°•í•˜ê²Œ
        engineForce = 0;
      }

      // ì—”ì§„ í˜ ì•ë°”í€´ì— ì ìš© (í›„ë¥œ êµ¬ë™ ê°€ì •)
      vehicle.applyEngineForce(engineForce, 2);
      vehicle.applyEngineForce(engineForce, 3);
    }

    // ì†ë„ ì¸¡ì • (m/s -> km/h)
    function getSpeedKmH() {
      const velocity = chassisBody.velocity;
      return velocity.length() * 3.6;
    }

    // ì¹´ë©”ë¼ ì°¨ëŸ‰ ë’¤ìª½ ìœ„ì¹˜ë¡œ ê³ ì •
    function updateCamera() {
  const relativeCameraOffset = new THREE.Vector3(0, 7, 15);
  const cameraOffset = relativeCameraOffset.applyMatrix4(carModel.matrixWorld);
  camera.position.lerp(cameraOffset, 0.1);
  camera.lookAt(carModel.position);
    }

    // íƒ€ì´ë¨¸ ê´€ë¦¬
    let startTime = null;
    let elapsedTime = 0;

    function startTimer() {
      startTime = performance.now();
    }

    function updateTimer() {
      if (startTime === null) return;
      elapsedTime = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `íƒ€ì´ë¨¸: ${elapsedTime.toFixed(2)} s`;
    }

    // ì• ë‹ˆë©”ì´ì…˜ ë° ë¬¼ë¦¬ ë£¨í”„
    const clock = new THREE.Clock();

// ----------------- ë©€í‹°í”Œë ˆì´ ê´€ë ¨ ì¶”ê°€ ì½”ë“œ -----------------

let playerId = null; 
  let otherPlayers = {};  
  socket.on('playerId', (id) => {
  playerId = id; // ì €ì¥ìš©
  console.log('ë‚´ ID:', id); // ë””ë²„ê¹…ìš©
});

  let loadedFont = null;
  
function loadFontAsync() {
  return new Promise((resolve, reject) => {
    if (loadedFont) {
      resolve(loadedFont);
    } else {
      fontLoader.load(
        'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
        (font) => {
          loadedFont = font;
          resolve(font);
        },
        undefined,
        (err) => reject(err)
      );
    }
  });
}

// textë¥¼ ë°›ì•„ì„œ Promiseë¡œ í…ìŠ¤ì³ ë©”ì‰¬ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
async function createTextMesh(text) {
  const font = await loadFontAsync();

  const geometry = new TextGeometry(text, {
    font: font,
    size: 0.6,
    height: 0.1,
    curveSegments: 12,
  });

  const material = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const mesh = new THREE.Mesh(geometry, material);

  return mesh;
}

// ì„œë²„ë¡œ ë‚´ í˜„ì¬ ìœ„ì¹˜, íšŒì „, ì…ë ¥, ê¸°ì–´ ìƒíƒœë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ë³´ë‚´ëŠ” í•¨ìˆ˜
function sendPlayerState() {
  if (!playerId) return;

  socket.emit('updatePosition', {
    position: {
      x: chassisBody.position.x,
      y: chassisBody.position.y,
      z: chassisBody.position.z
    },
    rotation: {
      x: chassisBody.quaternion.x,
      y: chassisBody.quaternion.y,
      z: chassisBody.quaternion.z,
      w: chassisBody.quaternion.w
    },
    gear: gearState
  });
}
// ì˜ˆì‹œ: í‚¤ ì…ë ¥ ì²˜ë¦¬ í›„
socket.emit('updateInput', input);
  const targetQuaternion = new THREE.Quaternion(); // íšŒì „ ë³´ê°„ìš©
socket.on('updatePlayers', async (players) => {
  for (const [id, player] of Object.entries(players)) {
    if (id === playerId) continue;

if (
  !player?.position || typeof player.position.x !== 'number' ||
  !player?.rotation || typeof player.rotation.w !== 'number'
) {
  continue; // ì˜ëª»ëœ í”Œë ˆì´ì–´ ë°ì´í„° â†’ ë¬´ì‹œ
}
    
    if (!otherPlayers[id]) {
      let otherCar;

      switch (player.carModel) {
        case 'SportsCar':
          otherCar = createSportsCar(player.carColor || '#aaaaaa');
          break;
        case 'SUV':
          otherCar = createSUVCar(player.carColor || '#aaaaaa');
          break;
        default:
          otherCar = createGrandeurIGCarDetailed(player.carColor || '#aaaaaa');
      }

      // ë‹‰ë„¤ì„ í‘œì‹œ
      const nicknameText = await createTextMesh(player.nickname);
      nicknameText.position.set(0, 2, 0);
      otherCar.add(nicknameText);

      scene.add(otherCar);

      otherPlayers[id] = {
        model: otherCar,
        targetPosition: new THREE.Vector3(player.position.x, player.position.y, player.position.z),
        targetQuaternion: new THREE.Quaternion(
          player.rotation.x, player.rotation.y, player.rotation.z, player.rotation.w
        ),
      };
    } else {
      const playerData = otherPlayers[id];

      // âœ… ìœ„ì¹˜/íšŒì „ ë³´ê°„ìš© íƒ€ê²Ÿ ì—…ë°ì´íŠ¸
      playerData.targetPosition.set(player.position.x, player.position.y, player.position.z);
      playerData.targetQuaternion.set(player.rotation.x, player.rotation.y, player.rotation.z, player.rotation.w);

      // âœ… ì°¨ëŸ‰ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ (ë³€ê²½ ì‹œë§Œ ë°˜ì˜)
      playerData.model.traverse(child => {
        if (child.isMesh && child.name === 'MainBody' && child.material && child.material.color) {
          const newColor = new THREE.Color(player.carColor || '#888888');

          if (!child.material.color.equals(newColor)) {
            child.material = child.material.clone(); // ê³µìœ  ë°©ì§€
            child.material.color.copy(newColor);
          }
        }
      });
    }
  }

  // ì œê±°ëœ í”Œë ˆì´ì–´ ì²˜ë¦¬
  for (const id of Object.keys(otherPlayers)) {
    if (!players[id]) {
      scene.remove(otherPlayers[id].model);
      delete otherPlayers[id];
    }
  }
});

// ë§¤ í”„ë ˆì„ ë˜ëŠ” 50ms ê°„ê²©ìœ¼ë¡œ ë‚´ ìœ„ì¹˜/ìƒíƒœ ì„œë²„ ì „ì†¡
  setInterval(() => {
    socket.emit('updateInput', input);
  }, 50);

  // ìœ„ì¹˜ ìƒíƒœ ì „ì†¡
setInterval(() => {
  sendPlayerState();
}, 50);

// ------------------------------------------------------------

    
    function animate() {
       requestAnimationFrame(animate);

  // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í… (ì˜ˆì‹œ)
       const delta = clock.getDelta();

      updateVehicleControls();
      
      world.step(1/60, delta, 3);

  // ìë™ì°¨ ëª¨ë¸ ìœ„ì¹˜/íšŒì „ì„ ë¬¼ë¦¬ ë°”ë””ì— ë§ê²Œ ì—…ë°ì´íŠ¸
  carModel.position.copy(chassisBody.position);
  carModel.quaternion.copy(chassisBody.quaternion);

      // íœ  mesh ìœ„ì¹˜/íšŒì „ ì—…ë°ì´íŠ¸
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelHolders[i].position.copy(t.position);
        wheelHolders[i].quaternion.copy(t.quaternion);
      }

       // ğŸ’¡ ìƒëŒ€ë°© ì°¨ëŸ‰ ìœ„ì¹˜ ë³´ê°„ ì²˜ë¦¬
  const now = performance.now();
  for (const id in otherPlayers) {
    const player = otherPlayers[id];
    const model = player.model;
    const targetPos = player.targetPosition;
    const targetQuat = player.targetQuaternion;

    if (targetPos && targetQuat) {
      // ìœ„ì¹˜ ë³´ê°„
      model.position.lerp(targetPos, 0.2);

      // íšŒì „ ë³´ê°„
     model.quaternion.slerp(targetQuat, 0.1);}
  }


      // ì†ë„ UI ì—…ë°ì´íŠ¸
      hud.textContent = `ì†ë„: ${getSpeedKmH().toFixed(1)} km/h`;

      // ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸°
  if (cameraFollow) {
    updateCamera();
  } else {
    const carPos = carModel.position;

    const desiredX = carPos.x + camDistance * Math.sin(camElevation) * Math.sin(camAzimuth);
    const desiredY = carPos.y + camDistance * Math.cos(camElevation);
    const desiredZ = carPos.z + camDistance * Math.sin(camElevation) * Math.cos(camAzimuth);

    // ëª©í‘œ ìœ„ì¹˜ ë²¡í„° ìƒì„±
    const desiredPos = new THREE.Vector3(desiredX, desiredY, desiredZ);

    // í˜„ì¬ ì¹´ë©”ë¼ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ìœ„ì¹˜ê¹Œì§€ lerp (ë³´ê°„ê°’ 0.2 ~ 0.3 ê¶Œì¥)
    camera.position.lerp(desiredPos, 0.2);

    // ë¶€ë“œëŸ¬ìš´ ì‹œì„  ë°©í–¥ ë³´ê°„
    const currentLookAt = new THREE.Vector3();
    camera.getWorldDirection(currentLookAt);

    const desiredLookAt = carPos.clone().sub(camera.position).normalize();

    currentLookAt.lerp(desiredLookAt, 0.2);

    const lookAtTarget = camera.position.clone().add(currentLookAt);

    camera.lookAt(lookAtTarget);
  }

      // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
      updateTimer();

      renderer.render(scene, camera);
    }
      
  function startGame(modelName = 'GrandeurIG', color = '#ffffff', nickname) {
    socket.emit('joinGame', {
  nickname: nickname,
  carModel: modelName,   // startGame(modelName, color) ì•ˆì—ì„œ ë°›ì€ modelName ì‚¬ìš©
  carColor: color
});
  switch (modelName) {
    case 'GrandeurIG':
      carModel = createGrandeurIGCarDetailed(color);
      break;
    case 'SportsCar':
      carModel = createSportsCar(color);
      break;
    case 'SUV':
      carModel = createSUVCar(color);
      break;
    default:
      carModel = createGrandeurIGCarDetailed(color);
  }

  scene.add(carModel);
  startTimer();
  updateGearDisplay();
  animate();
  }
    
  </script>
</body>
</html>
